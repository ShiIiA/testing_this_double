# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rRSegdTULlczjwu11IQzYDFAIJmlE8TF
"""

import os
import io
import logging
import warnings
import streamlit as st
import pandas as pd
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.models as models
import torchvision.transforms as transforms
from PIL import Image

# Suppress warnings
warnings.filterwarnings("ignore")

# ------------------------- PAGE CONFIGURATION -------------------------
st.set_page_config(
    page_title="Dynamic Medical AI",
    page_icon="üî¨",
    layout="wide"
)

# ------------------------- GLOBAL SESSION STATE -------------------------
if "df" not in st.session_state:
    st.session_state.df = None
if "disease_col" not in st.session_state:
    st.session_state.disease_col = None
if "gender_col" not in st.session_state:
    st.session_state.gender_col = None
if "disease_classes" not in st.session_state:
    st.session_state.disease_classes = []
if "model_loaded" not in st.session_state:
    st.session_state.model_loaded = False
if "device" not in st.session_state:
    st.session_state.device = "cpu"

# ------------------------- UPLOAD DATASET -------------------------
st.title("üìÇ Upload Medical Dataset")
uploaded_file = st.file_uploader("Upload your dataset (CSV/XLSX)", type=["csv", "xlsx"])

if uploaded_file:
    try:
        df = pd.read_csv(uploaded_file) if uploaded_file.name.endswith(".csv") else pd.read_excel(uploaded_file)
        st.session_state.df = df
        st.write("**Preview of Uploaded Data:**")
        st.dataframe(df.head())

        # Allow user to select gender and disease columns
        st.session_state.gender_col = st.selectbox("Select Gender Column", df.columns.tolist())
        st.session_state.disease_col = st.selectbox("Select Disease Column", df.columns.tolist())

        # Extract unique disease values dynamically
        disease_classes = df[st.session_state.disease_col].dropna().unique().tolist()
        st.session_state.disease_classes = sorted(disease_classes)

        if not disease_classes:
            st.warning("‚ö†Ô∏è No diseases detected in the selected column.")
        else:
            st.success(f"‚úÖ Detected {len(disease_classes)} diseases: {', '.join(disease_classes)}")

    except Exception as e:
        logging.error("Error loading file", exc_info=True)
        st.error(f"üö® Error loading file: {e}")

# ------------------------- LOAD CHEXNET MODEL -------------------------
@st.cache_resource(show_spinner=True)
def load_chexnet_model(num_classes):
    model = models.densenet121(weights=models.DenseNet121_Weights.IMAGENET1K_V1)
    model.classifier = nn.Linear(1024, num_classes)  # Dynamically adjust output size
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = model.to(device)
    model.eval()
    return model, device

if st.session_state.disease_classes:
    num_classes = len(st.session_state.disease_classes)
    if not st.session_state.model_loaded:
        chexnet_model, device = load_chexnet_model(num_classes)
        st.session_state.model_loaded = True
        st.session_state.device = device
        st.success("‚úÖ Model Loaded Successfully!")

# ------------------------- PREPROCESS IMAGE -------------------------
def preprocess_image(image):
    transform = transforms.Compose([
        transforms.Resize((224, 224)),
        transforms.ToTensor()
    ])
    return transform(image).unsqueeze(0)

# ------------------------- MODEL PREDICTION -------------------------
def predict_disease(image):
    if not st.session_state.disease_classes:
        st.error("‚ùå No diseases detected from dataset. Please upload a dataset with disease labels.")
        return None, None

    tensor_img = preprocess_image(image).to(st.session_state.device)
    with torch.no_grad():
        logits = chexnet_model(tensor_img)
        probs = F.softmax(logits, dim=1)  # Multi-class probabilities

        # Dynamically assign labels
        THRESHOLD = 0.5
        predicted_labels = [st.session_state.disease_classes[i] for i, prob in enumerate(probs[0]) if prob >= THRESHOLD]
        if not predicted_labels:
            predicted_labels.append("No Disease")
    return ", ".join(predicted_labels), probs.max().item()

# ------------------------- IMAGE UPLOAD AND PREDICTION -------------------------
st.title("üñºÔ∏è Predict Diseases from X-ray Images")
uploaded_images = st.file_uploader("Upload X-ray Images", type=["png", "jpg", "jpeg"], accept_multiple_files=True)

if uploaded_images:
    for img in uploaded_images:
        st.image(img, caption=f"Uploaded: {img.name}", width=300)

        # Perform prediction
        image = Image.open(img).convert("RGB")
        pred_disease, confidence = predict_disease(image)

        if pred_disease:
            st.success(f"ü¶† **Predicted Disease(s):** {pred_disease} | **Confidence:** {confidence:.2%}")

# ------------------------- EXPLORATORY DATA ANALYSIS -------------------------
if st.session_state.df is not None:
    st.title("üìä Explore Data & Visualizations")

    # Disease Frequency Visualization
    disease_counts = st.session_state.df[st.session_state.disease_col].value_counts()
    st.bar_chart(disease_counts)

    # Display missing values
    st.write("### Missing Values")
    st.dataframe(st.session_state.df.isnull().sum())

# ------------------------- BIAS DETECTION -------------------------
st.title("‚öñÔ∏è Gender Bias Analysis")
if st.session_state.df is not None:
    gender_col = st.session_state.gender_col
    disease_col = st.session_state.disease_col

    if gender_col and disease_col:
        # Compute Bias Metrics
        df_filtered = st.session_state.df[[gender_col, disease_col]].dropna()
        bias_summary = df_filtered.groupby(gender_col)[disease_col].value_counts(normalize=True).reset_index(name="Proportion")
        st.write("### Bias Analysis Results")
        st.dataframe(bias_summary)

        # Visualizing Gender Bias
        import plotly.express as px
        bias_chart = px.bar(bias_summary, x=gender_col, y="Proportion", color=disease_col, title="Gender Bias in Disease Predictions")
        st.plotly_chart(bias_chart)

# ------------------------- END OF APP -------------------------
st.success("üéØ **App Ready!** Upload a dataset, make predictions, and analyze bias.")